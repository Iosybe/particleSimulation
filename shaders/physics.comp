#version 430 core

layout (local_size_x = 16, local_size_y = 8, local_size_z = 1) in;

struct Particle {
    vec2 pos;
    vec2 vel;
    float mass;
};

layout(std430, binding = 1) buffer particlesBuffer {
    int nopM1;
    int nopX128;
    Particle particles[];
};

layout(std430, binding = 2) buffer velocityBuffer {
    vec2 velBuffer[];
};

void main() {
    // Give nopM1 / 2 a variable
    if (gl_GlobalInvocationID.y > nopM1 / 2) {
        return;
    }

    // Can't give these proper names, because there multifunctional
    ivec2 particleIndices;
    ivec2 bufferIndices;

    // Maybe turnary? Maybe conditional *?
    if (gl_GlobalInvocationID.x >= gl_GlobalInvocationID.y) {
        particleIndices = ivec2(gl_GlobalInvocationID.x + 1, gl_GlobalInvocationID.y);
        bufferIndices = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    }
    else {
        particleIndices = ivec2(nopM1 - gl_GlobalInvocationID.x, nopM1 - gl_GlobalInvocationID.y);
        bufferIndices = ivec2(nopM1 - gl_GlobalInvocationID.x - 1, nopM1 - gl_GlobalInvocationID.y);
    }

    // Putting this in if else could be faster or slower
    ivec2 velBufferIndices = ivec2(bufferIndices.y * nopX128 + bufferIndices.x, particleIndices.x * nopX128 + particleIndices.y);

    vec2 diff = particles[particleIndices.x].pos - particles[particleIndices.y].pos;
    float distance = length(diff);

    if (distance > 20) {
        float gravWeight = 1 / pow(distance, 3);

        vec2 gravFactor; 
        gravFactor.x = particles[particleIndices.y].mass * gravWeight;
        gravFactor.y = particles[particleIndices.x].mass * gravWeight;

        velBuffer[velBufferIndices.x] = gravFactor.xx * diff;
        velBuffer[velBufferIndices.y] = -gravFactor.yy * diff;
    }
    else {
        velBuffer[velBufferIndices.x] = 0.0.xx;
        velBuffer[velBufferIndices.y] = 0.0.xx;
    }
}

// -----------------------------------

// void main() {
//     float diffX = particles[gl_GlobalInvocationID.x].pos.x - particles[gl_GlobalInvocationID.y].pos.x;
//     float diffY = particles[gl_GlobalInvocationID.x].pos.y - particles[gl_GlobalInvocationID.y].pos.y;
    
//     float distance = sqrt(diffX * diffX + diffY * diffY);

//     bool valid = distance > 20;

//     float gravWeight = 1 / (distance * distance * distance);

//     vec2 gravFactor;
//     gravFactor.x = -particles[gl_GlobalInvocationID.y].mass * gravWeight * valid;
//     gravFactor.y = particles[gl_GlobalInvocationID.x].mass * gravWeight * valid;

//     velBuffer[].x = gravFactor.x * diffX;
//     velBuffer[].y = gravFactor.x * diffY;

//     velBuffer[].x = gravFactor.y * diffX;
//     velBuffer[].y = gravFactor.y * diffY;

//     // if (distance > 20) {
//     //     float gravWeight = 1 / (distance * distance * distance);

//     //     vec2 gravFactor;
//     //     gravFactor.x = -particles[gl_GlobalInvocationID.y].mass * gravWeight;
//     //     gravFactor.y = particles[gl_GlobalInvocationID.x].mass * gravWeight;

//     //     velBuffer[].x = gravFactor.x * diffX;
//     //     velBuffer[].y = gravFactor.x * diffY;

//     //     velBuffer[].x = gravFactor.y * diffX;
//     //     velBuffer[].y = gravFactor.y * diffY;
//     // }
//     // else {
//     //     velBuffer[].x = 0.0;
//     //     velBuffer[].y = 0.0;

//     //     velBuffer[].x = 0.0;
//     //     velBuffer[].y = 0.0;
//     // }
// }